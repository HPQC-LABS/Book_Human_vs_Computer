WolframAlpha: 2^(2^33) doesn't work, but it can do: 2^(2^60). 
WolframAlpha: (((((3)!)!)!)!)^(1/2^1075) results in 10^(10^1426.35...), But adding an additional square root for (((((3)!)!)!)!)^(1/2^1076) results in "(cannot be determined using current methods)". It might be trying to do the 2^1076th root rather than the square root multiple times. What's special about 1076? For me it works if I do anything smaller than (or equal to) 2^(2^32) or larger than (or equal to) 2^(2^52) but nothing in between. Maybe it switches from using some floating-point system to a symbolic system for exponents of size 2^52 and larger! Notice that 2^(2^52) works, but does not give the actual value, it only says the "number of digits of the value" and the last 10 digits. In Mathematica if you run the command $MaxNumber (the largest number that can be represented on your hardware if you have a 64-bit machine), you will get: 1.605216761933662*10^1355718576299609. Then if you do log2(log2( $MaxNumber ) you get 51.9999999999999589961407511684709. So 64-bit machines cannot do 2^(2^52) and therefore WolframAlpha switches to a different algorithm where it doesn't even try to calculate the number, but instead prints just the last 10 digits and the length of the number. So that answers why everything equal to or larger than 2^(2^52) works. It is still a mystery why 2^(2^33) doesn't work though. It is indeed huge, but only 2x the size of 2^(2^32) which works. Maybe there's an arbitrary cut-off. Okay. 2^(2^32) is 1.3 billion digits, and would take up about 1GB of RAM to store/print. 2^(2^33) would be 2GB, 2^(2^34) would be 4GB, etc. so it's not really realistic to print out 2^(2^x) for x much larger than 32. WolframAlpha probably set 1GB as the cut-off point where it stops bothering to print out 2^(2^x). It would be nice if at x=33 it switched to the x=52 algorithm, which doesn't bother to print out the final number, but does print out the last 10 digits and the number of digits. ea ideally at x=33 it would switch to the algorithm that is used for x >= 52, where only the last 10 digits are printed. As for the algorithm, to do x^n I think they do it recursively: x <- x^2 , x <- x^2 (now we have x^4) , x <- x^2 (now we have x^8), ... which only needs to be repeated 2^32 < 5 billion times. At 100 GFLOPS a modern computer can do that in seconds. I never considered how the x >= 52 algorithm works for printing out the last 10 digits so quickly. Apparently there's some way to print out only the least significant digits: https://stackoverflow.com/a/9437208/1271772

Desmos: x^x-e^(x ln x), it goes crazy as x moves away from 0, particularly from 11 to 143 - then it just cuts out. WolframAlpha does it symbolically bit Desmos does it numerically. Nike talks about the specific details of what might happened in Messenger with Vince
